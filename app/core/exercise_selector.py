"""
Intelligent exercise selection engine using natural language understanding.

This module focuses purely on natural language understanding without any hardcoded biases.
It uses the second LLM to intelligently curate routines based on:
- Exercise stories from the first LLM
- Clip details from vector search
- User requirements
- Content similarity analysis

The goal is to create thoughtful, well-rounded routines that avoid duplicates
based on content similarity, not just IDs.
"""

import asyncio
import json
import logging
import os
import time
from typing import Dict, List, Optional, Tuple
from dotenv import load_dotenv
import google.generativeai as genai

# Load environment variables
load_dotenv()

logger = logging.getLogger(__name__)

class ExerciseSelector:
    """
    Intelligent exercise selector using natural language understanding.
    
    This selector focuses purely on content analysis and natural language
    understanding without any hardcoded exercise knowledge or biases.
    """
    
    def __init__(self):
        """Initialize the exercise selector."""
        self._gemini_model = None
        self._openai_client = None
    
    def _get_gemini_model(self, use_backup=False):
        """Get Gemini model instance."""
        if self._gemini_model is None:
            api_key = os.getenv("GEMINI_API_BACKUP_KEY" if use_backup else "GEMINI_API_KEY")
            genai.configure(api_key=api_key)
            self._gemini_model = genai.GenerativeModel('gemini-2.5-flash')
        return self._gemini_model
    
    def _get_openai_client(self):
        """Get OpenAI client instance."""
        if self._openai_client is None:
            from openai import OpenAI
            self._openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        return self._openai_client
    
    async def select_intelligent_routine(
        self,
        candidate_clips: List[Dict],
        requirement_stories: List[str],
        user_requirements: str,
        target_duration: int,
        intensity_level: str
    ) -> List[Dict]:
        """
        Intelligently select exercises for a well-rounded routine.
        
        This method uses natural language understanding to:
        1. Analyze content similarity between clips
        2. Create a thoughtful, well-rounded routine
        3. Avoid duplicates based on content, not just IDs
        4. Ensure the routine meets user requirements
        
        Args:
            candidate_clips: List of clips from vector search
            requirement_stories: Stories from first LLM
            user_requirements: Original user requirements
            target_duration: Target routine duration
            intensity_level: Desired intensity level
            
        Returns:
            List of selected exercises for the routine
        """
        try:
            logger.info(f"Starting intelligent exercise selection for {len(candidate_clips)} candidate clips")
            
            # Step 1: Prepare context for the second LLM
            context = self._prepare_selection_context(
                candidate_clips, requirement_stories, user_requirements,
                target_duration, intensity_level
            )
            
            # Step 2: Use second LLM to intelligently select exercises
            selected_exercises = await self._curate_routine_with_llm(context)
            
            # Step 3: Validate and finalize selection
            final_selection = self._validate_and_finalize_selection(
                selected_exercises, candidate_clips, target_duration
            )
            
            logger.info(f"Selected {len(final_selection)} exercises for routine")
            return final_selection
            
        except Exception as e:
            logger.error(f"Error in intelligent exercise selection: {str(e)}")
            # Fallback to simple selection
            return self._fallback_selection(candidate_clips, target_duration)
    
    async def select_routine_from_stories_and_results(
        self,
        original_prompt: str,
        exercise_stories: List[str],
        exercise_results: List[Dict]
    ) -> List[str]:
        """
        Select the best exercises for a routine based on stories and search results.
        
        This function takes the exercise stories generated by the first LLM and the
        enriched exercise results from vector search, then uses a second LLM to
        intelligently select and order the best exercises for the routine.
        
        Args:
            original_prompt: The original user prompt/requirements
            exercise_stories: List of exercise stories from the first LLM
            exercise_results: List of enriched exercise results from vector search
            
        Returns:
            List of database IDs in the order they should appear in the routine
        """
        try:
            logger.info(f"Starting routine selection from {len(exercise_stories)} stories and {len(exercise_results)} results")
            
            # Step 1: Prepare context for the LLM
            context = self._prepare_routine_selection_context(
                original_prompt, exercise_stories, exercise_results
            )
            
            # Step 2: Use LLM to select and order exercises
            selected_ids = await self._select_routine_with_llm(context)
            
            # Step 3: Validate the selection
            validated_ids = self._validate_database_ids(selected_ids, exercise_results)
            
            logger.info(f"Selected {len(validated_ids)} exercises for routine")
            return validated_ids
            
        except Exception as e:
            logger.error(f"Error in routine selection: {str(e)}")
            # Fallback to simple selection
            return self._fallback_routine_selection(exercise_results)
    
    def _prepare_selection_context(
        self,
        candidate_clips: List[Dict],
        requirement_stories: List[str],
        user_requirements: str,
        target_duration: int,
        intensity_level: str
    ) -> str:
        """Prepare comprehensive context for the second LLM."""
        
        # Create detailed clip information
        clips_info = []
        for i, clip in enumerate(candidate_clips):
            clip_info = f"""
Clip {i+1}:
- Name: {clip['exercise_name']}
- Duration: {clip['end_time'] - clip['start_time']:.1f}s
- Instructions: {clip['how_to']}
- Benefits: {clip['benefits']}
- Problems it solves: {clip['counteracts']}
- Fitness Level: {clip['fitness_level']}/10
- Intensity: {clip['intensity']}/10
- Relevance Score: {clip['relevance_score']:.3f}
- Story Match: {clip['requirement_story']}
"""
            clips_info.append(clip_info)
        
        context = f"""
USER REQUIREMENTS: {user_requirements}

TARGET DURATION: {target_duration} seconds
INTENSITY LEVEL: {intensity_level}

REQUIREMENT STORIES (from first LLM):
{chr(10).join(f"- {story}" for story in requirement_stories)}

AVAILABLE EXERCISE CLIPS ({len(candidate_clips)} total):
{chr(10).join(clips_info)}

TASK: Create a thoughtful, well-rounded workout routine by selecting exercises from the available clips.

SELECTION CRITERIA:
1. CONTENT UNIQUENESS: Avoid exercises that are too similar in movement patterns, target areas, or execution style
2. ROUTINE FLOW: Create logical progression and variety in the workout
3. REQUIREMENT ALIGNMENT: Ensure exercises address the user's specific needs
4. DURATION FIT: Stay within target duration while maintaining quality
5. INTENSITY MATCH: Match the desired intensity level
6. WELL-ROUNDED: Ensure the routine covers different aspects of fitness (strength, mobility, etc.)

ANALYSIS APPROACH:
- Compare exercise instructions, benefits, and movement patterns
- Look for natural progression and variety
- Consider how exercises complement each other
- Avoid redundancy while maintaining effectiveness

Please analyze the clips and select the best combination for a complete, effective routine.
"""
        
        return context
    
    def _prepare_routine_selection_context(
        self,
        original_prompt: str,
        exercise_stories: List[str],
        exercise_results: List[Dict]
    ) -> str:
        """Prepare comprehensive context for routine selection."""
        
        # Format exercise stories
        stories_text = "\n".join(f"{i+1}. {story}" for i, story in enumerate(exercise_stories))
        
        # Format exercise results with all required fields
        exercises_text = []
        for i, exercise in enumerate(exercise_results):
            exercise_text = f"""
Exercise {i+1}:
- Database ID: {exercise.get('database_id', 'N/A')}
- Exercise Name: {exercise.get('exercise_name', 'N/A')}
- How To: {exercise.get('how_to', 'N/A')}
- Benefits: {exercise.get('benefits', 'N/A')}
- Counteracts: {exercise.get('counteracts', 'N/A')}
- Fitness Level: {exercise.get('fitness_level', 'N/A')}/10
- Rounds/Reps: {exercise.get('rounds_reps', 'N/A')}
- Intensity: {exercise.get('intensity', 'N/A')}/10
- Relevance Score: {exercise.get('score', 0):.3f}
"""
            exercises_text.append(exercise_text)
        
        exercises_formatted = "\n".join(exercises_text)
        
        context = f"""
ORIGINAL USER PROMPT: {original_prompt}

EXERCISE STORIES (from first LLM):
{stories_text}

AVAILABLE EXERCISES ({len(exercise_results)} total):
{exercises_formatted}

TASK: Select the best exercises for a complete workout routine and return them in the optimal order.

SELECTION CRITERIA:
1. **Relevance**: Choose exercises that best match the user's requirements and the generated stories
2. **Variety**: Ensure a good mix of different movement patterns and target areas
3. **Progression**: Order exercises in a logical flow (warm-up → main work → cool-down)
4. **Fitness Level**: Consider the user's fitness level and choose appropriate exercises
5. **Intensity**: Create a balanced routine that matches the user's goals
6. **Completeness**: Ensure the routine addresses all aspects mentioned in the user's requirements

RETURN FORMAT:
Return ONLY a JSON array of database IDs in the order they should appear in the routine:

["database_id_1", "database_id_2", "database_id_3", ...]

The database IDs should be the exact values from the exercise data above.
Choose 5-10 exercises that create a complete, effective routine.
"""
        
        return context
    
    async def _curate_routine_with_llm(self, context: str) -> List[Dict]:
        """Use the second LLM to intelligently curate the routine."""
        
        prompt = f"""
{context}

Based on the available clips and requirements, please select the best exercises for a complete workout routine.

Return your response as a JSON array with the selected clip numbers (1-based) and reasoning:

{{
  "selected_clips": [
    {{
      "clip_number": 1,
      "reasoning": "This exercise provides a good warm-up and addresses the user's need for...",
      "role_in_routine": "warm-up/strength/mobility/etc"
    }}
  ],
  "routine_analysis": {{
    "total_duration": 0,
    "variety_score": 0.0,
    "progression_flow": "description of how exercises flow together",
    "requirement_coverage": "how well the routine addresses user needs",
    "uniqueness_analysis": "analysis of content diversity"
  }}
}}

Focus on creating a thoughtful, well-rounded routine that avoids content duplication.
"""
        
        try:
            # Try primary Gemini API
            try:
                gemini_model = self._get_gemini_model(use_backup=False)
                response = gemini_model.generate_content(prompt)
                logger.info("Successfully used primary Gemini API for routine curation")
            except Exception as primary_error:
                logger.warning(f"Primary Gemini API failed: {str(primary_error)}")
                logger.info("Attempting to use backup Gemini API...")
                
                # Try backup key
                gemini_model = self._get_gemini_model(use_backup=True)
                response = gemini_model.generate_content(prompt)
                logger.info("Successfully used backup Gemini API for routine curation")
            
            # Parse JSON response
            response_text = response.text.strip()
            logger.info(f"LLM response: {response_text[:200]}...")
            
            # Extract JSON from response
            json_start = response_text.find('{')
            json_end = response_text.rfind('}') + 1
            
            if json_start != -1 and json_end > json_start:
                json_str = response_text[json_start:json_end]
                selection_data = json.loads(json_str)
                
                return selection_data.get('selected_clips', [])
            else:
                logger.warning("Could not extract JSON from LLM response")
                return []
                
        except Exception as e:
            logger.error(f"Error in LLM routine curation: {str(e)}")
            return []
    
    async def _select_routine_with_llm(self, context: str) -> List[str]:
        """Use the LLM to select and order exercises for the routine."""
        
        prompt = f"""
{context}

Analyze the available exercises and the user's requirements. Select the best exercises for a complete workout routine and return them in the optimal order.

Return ONLY a JSON array of database IDs:

["database_id_1", "database_id_2", "database_id_3", ...]

Choose exercises that:
- Best match the user's requirements
- Provide good variety and progression
- Create a complete, effective routine
- Are appropriate for the user's fitness level

Return 5-10 exercises in the order they should be performed.
"""
        
        try:
            # Try primary Gemini API
            try:
                gemini_model = self._get_gemini_model(use_backup=False)
                response = gemini_model.generate_content(prompt)
                logger.info("Successfully used primary Gemini API for routine selection")
            except Exception as primary_error:
                logger.warning(f"Primary Gemini API failed: {str(primary_error)}")
                logger.info("Attempting to use backup Gemini API...")
                
                # Try backup key
                gemini_model = self._get_gemini_model(use_backup=True)
                response = gemini_model.generate_content(prompt)
                logger.info("Successfully used backup Gemini API for routine selection")
            
            # Parse JSON response
            response_text = response.text.strip()
            logger.info(f"LLM response: {response_text[:200]}...")
            
            # Extract JSON array from response
            json_start = response_text.find('[')
            json_end = response_text.rfind(']') + 1
            
            if json_start != -1 and json_end > json_start:
                json_str = response_text[json_start:json_end]
                selected_ids = json.loads(json_str)
                
                if isinstance(selected_ids, list):
                    logger.info(f"LLM selected {len(selected_ids)} exercises")
                    return selected_ids
                else:
                    logger.warning("LLM response is not a list")
                    return []
            else:
                logger.warning("Could not extract JSON array from LLM response")
                return []
                
        except Exception as e:
            logger.error(f"Error in LLM routine selection: {str(e)}")
            return []
    
    def _validate_and_finalize_selection(
        self,
        llm_selection: List[Dict],
        candidate_clips: List[Dict],
        target_duration: int
    ) -> List[Dict]:
        """Validate LLM selection and finalize the routine."""
        
        selected_clips = []
        total_duration = 0
        
        for selection in llm_selection:
            clip_number = selection.get('clip_number', 0)
            
            # Validate clip number
            if 1 <= clip_number <= len(candidate_clips):
                clip = candidate_clips[clip_number - 1]
                duration = clip['end_time'] - clip['start_time']
                
                # Check if adding this clip would exceed target duration
                if total_duration + duration <= target_duration:
                    selected_clips.append(clip)
                    total_duration += duration
                else:
                    logger.info(f"Skipping clip {clip_number} - would exceed target duration")
            else:
                logger.warning(f"Invalid clip number: {clip_number}")
        
        logger.info(f"Final selection: {len(selected_clips)} clips, {total_duration:.1f}s total")
        return selected_clips
    
    def _validate_database_ids(self, selected_ids: List[str], exercise_results: List[Dict]) -> List[str]:
        """Validate that the selected database IDs exist in the exercise results."""
        
        # Create set of valid database IDs from exercise results
        valid_ids = set()
        for exercise in exercise_results:
            database_id = exercise.get('database_id')
            if database_id:
                valid_ids.add(str(database_id))
        
        # Filter and validate selected IDs
        validated_ids = []
        for selected_id in selected_ids:
            if str(selected_id) in valid_ids:
                validated_ids.append(str(selected_id))
            else:
                logger.warning(f"Selected database ID not found in results: {selected_id}")
        
        logger.info(f"Validated {len(validated_ids)} out of {len(selected_ids)} selected IDs")
        return validated_ids
    
    def _fallback_selection(self, candidate_clips: List[Dict], target_duration: int) -> List[Dict]:
        """Fallback selection when LLM fails."""
        logger.info("Using fallback selection method")
        
        selected_clips = []
        total_duration = 0
        
        # Simple selection: take clips until we reach target duration
        for clip in candidate_clips:
            duration = clip['end_time'] - clip['start_time']
            
            if total_duration + duration <= target_duration:
                selected_clips.append(clip)
                total_duration += duration
            else:
                break
        
        logger.info(f"Fallback selection: {len(selected_clips)} clips, {total_duration:.1f}s total")
        return selected_clips
    
    def _fallback_routine_selection(self, exercise_results: List[Dict]) -> List[str]:
        """Fallback selection when LLM fails."""
        logger.info("Using fallback routine selection method")
        
        # Simple selection: take first 5 exercises with valid database IDs
        selected_ids = []
        for exercise in exercise_results:
            database_id = exercise.get('database_id')
            if database_id and len(selected_ids) < 5:
                selected_ids.append(str(database_id))
        
        logger.info(f"Fallback selection: {len(selected_ids)} exercises")
        return selected_ids
    
    async def create_final_routine_json(
        self,
        selected_database_ids: List[str],
        exercise_results: List[Dict]
    ) -> Dict:
        """
        Create the final JSON structure for the UI with all required fields.
        
        This function takes the ordered database IDs and creates a comprehensive
        JSON structure that includes:
        - UI display fields (exercise_name, how_to, benefits, etc.)
        - Database operation information (database_id, qdrant_id, video_path)
        
        Args:
            selected_database_ids: Ordered list of database IDs for the routine
            exercise_results: All exercise results from vector search (for lookup)
            
        Returns:
            Dictionary with routine data and metadata for UI and database operations
        """
        try:
            logger.info(f"Creating final routine JSON for {len(selected_database_ids)} exercises")
            
            # Create lookup dictionary for quick access to exercise data
            exercise_lookup = {}
            for exercise in exercise_results:
                database_id = exercise.get('database_id')
                if database_id:
                    exercise_lookup[str(database_id)] = exercise
            
            # Build the routine exercises array
            routine_exercises = []
            routine_metadata = {
                'total_exercises': len(selected_database_ids),
                'database_operations': {
                    'database_ids': [],
                    'qdrant_ids': [],
                    'video_paths': []
                }
            }
            
            for i, database_id in enumerate(selected_database_ids, 1):
                exercise_data = exercise_lookup.get(database_id)
                
                if exercise_data:
                    # Create exercise object for UI
                    exercise_object = {
                        'order': i,
                        'exercise_name': exercise_data.get('exercise_name', 'Unknown Exercise'),
                        'how_to': exercise_data.get('how_to', 'Instructions not available'),
                        'benefits': exercise_data.get('benefits', 'Benefits not specified'),
                        'counteracts': exercise_data.get('counteracts', 'Not specified'),
                        'fitness_level': exercise_data.get('fitness_level', 5),
                        'rounds_reps': exercise_data.get('rounds_reps', 'Follow video instructions'),
                        'intensity': exercise_data.get('intensity', 5)
                    }
                    
                    routine_exercises.append(exercise_object)
                    
                    # Add metadata for database operations
                    routine_metadata['database_operations']['database_ids'].append(database_id)
                    routine_metadata['database_operations']['qdrant_ids'].append(exercise_data.get('qdrant_id'))
                    routine_metadata['database_operations']['video_paths'].append(exercise_data.get('video_path'))
                    
                    logger.info(f"Added exercise {i}: {exercise_data.get('exercise_name', 'Unknown')}")
                else:
                    logger.warning(f"Exercise data not found for database ID: {database_id}")
            
            # Create final JSON structure
            final_routine = {
                'routine': {
                    'exercises': routine_exercises,
                    'metadata': routine_metadata
                }
            }
            
            logger.info(f"Created final routine JSON with {len(routine_exercises)} exercises")
            return final_routine
            
        except Exception as e:
            logger.error(f"Error creating final routine JSON: {str(e)}")
            return {
                'routine': {
                    'exercises': [],
                    'metadata': {
                        'total_exercises': 0,
                        'database_operations': {
                            'database_ids': [],
                            'qdrant_ids': [],
                            'video_paths': []
                        }
                    }
                }
            }

# Global instance
exercise_selector = ExerciseSelector() 